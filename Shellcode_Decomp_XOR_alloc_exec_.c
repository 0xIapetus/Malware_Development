// Piece of self modifying code,
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/mman.h>
#include <math.h>

// -----------------------------------------------------------------------------------------------------------
// What this sample does is instead of executing the function below which in another case could be malicious code 

// int myFunc(int num1, int num2) {
//  return num1 + num2;

//  we translate that to byte code that correlates to this function

// unsigned char byteCode[] = {
// 0x55, 0x48, 0x89, 0xe5, 0x89, 0x7d, 0xfc, 0x89, 0x75, 0xf8,
//  0x8b , 0x55, 0xfc ,0x8b, 0x45, 0xf8, 0x01, 0xd0, 0x5d, 0xc3
// };

// Then for extra stealthiness of our code, we decompress then xor it and then execute it.
// The steps to achieve this are the following :
// Xor the final payload with a value that you like in our case the key is 0xAA and save that to a result
// Then compress the result and save that a variable in our case : compressedData. 
// Now you are ready to go, just take this hardcoded to your code and decompress it, xor and execute it :)
// The commented out functionalities were used to build the payload.
// ------------------------------------------------------------------------------------------------------------
// uint32_t lz77_compress (uint8_t *uncompressed_text, uint32_t uncompressed_size, uint8_t *compressed_text, uint8_t pointer_length_width)
// {
//     uint16_t pointer_pos, temp_pointer_pos, output_pointer, pointer_length, temp_pointer_length;
//     uint32_t compressed_pointer, output_size, coding_pos, output_lookahead_ref, look_behind, look_ahead;
//     uint16_t pointer_pos_max, pointer_length_max;
//     pointer_pos_max = pow(2, 16 - pointer_length_width);
//     pointer_length_max = pow(2, pointer_length_width);

//     *((uint32_t *) compressed_text) = uncompressed_size;
//     *(compressed_text + 4) = pointer_length_width;
//     compressed_pointer = output_size = 5;
    
//     for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)
//     {
//         pointer_pos = 0;
//         pointer_length = 0;
//         for(temp_pointer_pos = 1; (temp_pointer_pos < pointer_pos_max) && (temp_pointer_pos <= coding_pos); ++temp_pointer_pos)
//         {
//             look_behind = coding_pos - temp_pointer_pos;
//             look_ahead = coding_pos;
//             for(temp_pointer_length = 0; uncompressed_text[look_ahead++] == uncompressed_text[look_behind++]; ++temp_pointer_length)
//                 if(temp_pointer_length == pointer_length_max)
//                     break;
//             if(temp_pointer_length > pointer_length)
//             {
//                 pointer_pos = temp_pointer_pos;
//                 pointer_length = temp_pointer_length;
//                 if(pointer_length == pointer_length_max)
//                     break;
//             }
//         }
//         coding_pos += pointer_length;
//         if((coding_pos == uncompressed_size) && pointer_length)
//         {
//             output_pointer = (pointer_length == 1) ? 0 : ((pointer_pos << pointer_length_width) | (pointer_length - 2));
//             output_lookahead_ref = coding_pos - 1;
//         }
//         else
//         {
//             output_pointer = (pointer_pos << pointer_length_width) | (pointer_length ? (pointer_length - 1) : 0);
//             output_lookahead_ref = coding_pos;
//         }
//         *((uint16_t *) (compressed_text + compressed_pointer)) = output_pointer;
//         compressed_pointer += 2;
//         *(compressed_text + compressed_pointer++) = *(uncompressed_text + output_lookahead_ref);
//         output_size += 3;
//     }

//     return output_size;
// }

uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)
{
    uint8_t pointer_length_width;
    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;
    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;

    uncompressed_size = *((uint32_t *) compressed_text);
    pointer_length_width = *(compressed_text + 4);
    compressed_pointer = 5;

    pointer_length_mask = pow(2, pointer_length_width) - 1;

    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)
    {
        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));
        compressed_pointer += 2;
        pointer_pos = input_pointer >> pointer_length_width;
        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;
        if(pointer_pos)
            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)
                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];
        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);
    }

    return coding_pos;
}

void xorEncryptDecrypt(unsigned char *data, size_t dataLen, unsigned char key) {
    for (size_t i = 0; i < dataLen; i++) {
        data[i] ^= key; // XOR each byte with the key
      
    }

}
// Function to print data in hex format
// void print_hex_data(uint8_t *data, uint32_t size) {
//     for (uint32_t i = 0; i < size; i++) {
//         printf("%02x ", data[i]);
//         if ((i + 1) % 16 == 0) {
//             printf("\n");
//         }
//     }
//     printf("\n");
// }

int main() {

// Encrytped with xor 0xAA bytes :
// unsigned char yourCode[] = {
// 0xff, 0xe2,  0x23,  0x4f,  0x23,  0xd7, 0x56,  0x23,  0xdf,  0x52,  0x21,  0xff, 0x56,
//  0x21, 0xef,  0x52,  0xab, 0x7a,  0xf7, 0x69

// };
    // uint32_t yourCodeSize = sizeof(yourCode) / sizeof(yourCode[0]);
    // uint8_t pointerLengthWidth = 4; // Example, adjust based on your needs

    // // Buffer for compressed data, adjust size based on expectations
    // uint8_t compressedText[1024];
    // // Buffer for decompressed data
    // uint8_t decompressedText[sizeof(yourCode)];

    // // Compress
    // uint32_t compressedSize = lz77_compress(yourCode, yourCodeSize, compressedText, pointerLengthWidth);
    // printf("Compressed data (hex format):\n");
    //     print_hex_data(compressedText, compressedSize);

 unsigned char compressedData[] = {
        0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xff, 0x00, 0x00, 0xe2, 0x00, 0x00, 0x23, 0x00, 0x00,
        0x4f, 0x20, 0x00, 0xd7, 0x00, 0x00, 0x56, 0x30, 0x00, 0xdf, 0x00, 0x00, 0x52, 0x00, 0x00, 0x21,
        0xb0, 0x00, 0x56, 0x30, 0x00, 0xef, 0x60, 0x00, 0xab, 0x00, 0x00, 0x7a, 0x00, 0x00, 0xf7, 0x00,
        0x00, 0x69
    };
    uint32_t compressedDataSize = sizeof(compressedData);

    // Buffer for decompressed data
    uint8_t decompressedText1[1024]; // Adjust size as necessary

    // Decompress
    uint32_t decompressedSize = lz77_decompress(compressedData, decompressedText1);
// XOR DECRYPTION
unsigned char key = 0xAA; // XOR key
xorEncryptDecrypt(decompressedText1, compressedDataSize, key);

 // allocate memory to copy our function code into
 unsigned char *funcRaw = malloc(sizeof(decompressedText1));
 for (int i = 0; i < sizeof(decompressedText1); i++)
 funcRaw[i] = decompressedText1[i];

 // Find the memory address at the start of this memory page
 void *page = (void *)((uintptr_t)funcRaw & ~(getpagesize() - 1));

 // Set the page executable
 mprotect(page, getpagesize(), PROT_WRITE | PROT_EXEC);

 // declare a function pointer 'func' that takes 2 ints and returns an int
 int (*func)(int, int);

 // cast the pointer to the copied memory into the function pointer 'func'
 func = (int (*)(int, int))funcRaw;

 int param1 = 10; int param2 = 15;
 // call the new piece of code as a function
 int funcResult = func(param1, param2);
 // print the result
 printf("yourCode(%d, %d) = %d\n", param1, param2, funcResult);
}
