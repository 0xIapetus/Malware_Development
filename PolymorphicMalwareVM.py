import sys

# Operations (opcodes)

# We will do operands in the order 'src1, src2, dest' (or 'src, dest')

# MOVE constant register_num
# store the value of constant into the register
MOVE        = 0
# LOAD mem_addr register_num
# LOAD the value at mem_addr into register
LOAD        = 1
# STORE register_num mem_addr
# STORE the value in register into mem_addr
STORE       = 2
# ADD register_num1 register_num2 register_num3
# register_num3 := register_num1 + register_num2
ADD         = 3
# SUB register_num1 register_num2 register_num3
# register_num3 := register_num1 - register_num2
SUB         = 4
# IF_NOT_ZERO register_num1
# if (register_num1 != 0) { run next instruction } else { jump over next instruction }
IF_NOT_ZERO = 5
# IF_ZERO register_num1
# if (register_num1 == 0) { run next instruction } else { jump over next instruction }
IF_ZERO     = 6
# GOTO immediate
# Set 'PC' to the value in the immediate, ie move to the instruction at immediate
GOTO        = 7

class Instruction:
    def __init__(self, op_code, operand1, operand2=None, operand3=None):
        self.op_code = op_code
        self.operand1 = operand1
        self.operand2 = operand2
        self.operand3 = operand3

    def to_string(self):
        if self.op_code == MOVE:
            return f'MOVE {self.operand1} {self.operand2}'
        elif self.op_code == LOAD:
            return f'LOAD {self.operand1} {self.operand2}'
        elif self.op_code == STORE:
            return f'STORE {self.operand1} {self.operand2}'
        elif self.op_code == ADD:
            return f'ADD {self.operand1} {self.operand2} {self.operand3}'
        elif self.op_code == SUB:
            return f'SUB {self.operand1} {self.operand2} {self.operand3}'
        elif self.op_code == IF_NOT_ZERO:
            return f'IF_NOT_ZERO {self.operand1}'
        elif self.op_code == IF_ZERO:
            return f'IF_ZERO {self.operand1}'
        elif self.op_code == GOTO:
            return f'GOTO {self.operand1}'
        else:
            print(f'Invalid opcode ({self.op_code})')

class VirtualMachine:
    def __init__(self, program):
        self.program = program
        self.register = [0] * 6
        self.PC = 0
        self.memory = [0] * 8
    
    def execute_next_instruction(self):
        if self.PC >= len(self.program):
            print(f'Reached end of program (PC: {self.PC}, program length: {len(program)})')
            return
        instruction = self.program[self.PC]

        op_code = instruction.op_code
        if op_code == MOVE:
            self.register[instruction.operand2] = instruction.operand1
        elif op_code == LOAD:
            self.register[instruction.operand2] = self.memory[instruction.operand1]
        elif op_code == STORE:
            self.memory[instruction.operand2] = self.register[instruction.operand1]
        elif op_code == ADD:
            self.register[instruction.operand3] = self.register[instruction.operand1] + self.register[instruction.operand2]
        elif op_code == SUB:
            self.register[instruction.operand3] = self.register[instruction.operand1] - self.register[instruction.operand2]
        elif op_code == IF_NOT_ZERO:
            if self.register[instruction.operand1] == 0:
                self.PC += 1
        elif op_code == IF_ZERO:
            if self.register[instruction.operand1] != 0:
                self.PC += 1
        elif op_code == GOTO:
            if instruction.operand1 < 0 or instruction.operand1 >= len(self.program):
                print(f'ERROR: attempting to jump to instruction {instruction.operand1} in program of length {len(program)}')
                sys.exit(1)
            else:
                self.PC = instruction.operand1
                return
        else:
            print(f'ERROR: unrecognised op_code {op_code}')
            sys.exit(1)

        # move forward 1 instruction
        self.PC += 1
        if self.PC >= len(self.program):
            print(f'Reached end of program (len: {len(program)}), terminating. Final state:')
            self.print_state()
            return True

    def print_state(self):
        if self.PC < len(self.program):
            next_instr = self.program[self.PC].to_string()
        else:
            next_instr = 'N/A'
        print(f'PC: {self.PC}, registers: {self.register}, memory: {self.memory}, next_instruction: {next_instr}')

    

program = [
    Instruction(MOVE,        10, 0),       # reg[0] = 10
    Instruction(MOVE,        59, 1),       # reg[1] = 59
    Instruction(ADD,         1,  2,  2),   # reg[2] = reg[2] + reg[1]
    Instruction(STORE,       2,  0),       # memory[0] = reg[2]
    Instruction(LOAD,        0,  3),       # reg[3] = memory[0]
    Instruction(MOVE,        1,  4),       # reg[4] = 1
    Instruction(SUB,         0,  4,  0),   # reg[0] -= reg[4] (1)
    Instruction(IF_NOT_ZERO, 0),           # if reg[0] != 0
    Instruction(GOTO,        2),           #    goto 2
    Instruction(STORE,       2,  0),       # mem[0] = reg[2]
    Instruction(LOAD,        0,  0)        # reg[0] = mem[0]
]

def dump_machine_code_and_execute(program):
    machine_code = ''
    for instruction in program:
        machine_code += '{:02x}'.format(instruction.op_code)
        machine_code += '{:02x}'.format(instruction.operand1)
        if instruction.operand2 is not None:
            machine_code += '{:02x}'.format(instruction.operand2)
        if instruction.operand3 is not None:
            machine_code += '{:02x}'.format(instruction.operand3)
    print(machine_code)
    # To be implemented : here starts the execution of the machine code
#    i = 0
#    program = []
#    while i < len(machine_code):
#        opcode = int(machine_code[i:i+2], 16)
#        operand1 = int(machine_code[i+2:i+4], 16)
#        operand2 = operand3 = None
#        
#        if opcode in [MOVE, LOAD, STORE, GOTO]:
#            operand2 = int(machine_code[i+4:i+6], 16)
#            i += 6
#        elif opcode in [ADD, SUB]:
#            operand2 = int(machine_code[i+4:i+6], 16)
#            operand3 = int(machine_code[i+6:i+8], 16)
#            i += 8
#        elif opcode in [IF_NOT_ZERO, IF_ZERO]:
#            i += 4
#        else:
#            print(f"Unknown opcode {opcode} at byte {i}")
#            break
#
#        program.append(Instruction(opcode, operand1, operand2, operand3))
#        
#    return program
    
vm = VirtualMachine(program)
vm1 = dump_machine_code_and_execute(program)
while vm.execute_next_instruction() is None:
    vm.print_state()
